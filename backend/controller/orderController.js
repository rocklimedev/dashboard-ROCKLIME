const OrderItem = require("../models/orderItem");
const Comment = require("../models/comment");
const path = require("path");
const { v4: uuidv4 } = require("uuid");
const ftp = require("basic-ftp");
require("dotenv").config();
const { Op } = require("sequelize");
const sequelize = require("../config/database");
const sanitizeHtml = require("sanitize-html");
const { Readable } = require("stream");
const moment = require("moment");
const { sendNotification } = require("./notificationController"); // Import sendNotification
const { error } = require("console");
const {
  User,
  Order,
  Team,
  Invoice,
  Customer,
  Quotation,
  Address,
  Product,
  InventoryHistory,
} = require("../models");
// 2. Log to inventory history (id auto-generated by hook)
const { v7: uuidv7 } = require("uuid"); // Make sure this is imported at the top!
const { pipeline } = require("stream");
const { promisify } = require("util");
const pipe = promisify(pipeline);
// ──────── HELPERS ────────
const VALID_STATUSES = [
  "PREPARING",
  "CHECKING",
  "INVOICE",
  "DISPATCHED",
  "DELIVERED",
  "PARTIALLY_DELIVERED",
  "CANCELED",
  "DRAFT",
  "ONHOLD",
  "CLOSED", // ← NEW
];
const VALID_PRIORITIES = ["high", "medium", "low"];
// ──────── HELPERS ──────── (add near the top of the controller file)
const canDispatch = (order) => {
  // Gate-pass is mandatory **only** when moving to DISPATCHED
  return order.gatePassLink !== null && order.gatePassLink.trim() !== "";
};
// Assume an admin user ID or system channel for notifications
const ADMIN_USER_ID = "2ef0f07a-a275-4fe1-832d-fe9a5d145f60"; // Replace with actual admin user ID or channel

function bufferToStream(buffer) {
  const stream = new Readable();
  stream.push(buffer);
  stream.push(null);
  return stream;
}

const uploadToCDN = async (file) => {
  const client = new ftp.Client();
  client.ftp.verbose = process.env.NODE_ENV === "development";

  try {
    await client.access({
      host: process.env.FTP_HOST,
      port: process.env.FTP_PORT || 21,
      user: process.env.FTP_USER,
      password: process.env.FTP_PASSWORD,
      secure: process.env.FTP_SECURE === "true",
    });

    const cwd = await client.pwd();
    const uploadDir = "/invoice_pdfs";
    await client.ensureDir(uploadDir);
    await client.cd(uploadDir);

    const ext = path.extname(file.originalname);
    const uniqueName = `${uuidv4()}-${Date.now()}${ext}`;
    await client.uploadFrom(bufferToStream(file.buffer), uniqueName);
    const fileUrl = `${process.env.FTP_BASE_URL}/invoice_pdfs/${uniqueName}`;
    return fileUrl;
  } catch (err) {
    throw new Error(`FTP upload failed: ${err.message}`);
  } finally {
    client.close();
  }
};

const sendErrorResponse = (res, status, message, details = null) => {
  const response = { message };
  if (details) response.details = details;
  return res.status(status).json(response);
};

const validateResource = async (resourceId, resourceType) => {
  const validResourceTypes = {
    Order: Order,
    Product: Product,
    Customer: Customer,
  };

  const Model = validResourceTypes[resourceType];
  if (!Model) {
    return { valid: false, error: `Invalid resourceType: ${resourceType}` };
  }

  const resource = await Model.findByPk(resourceId);
  if (!resource) {
    return { valid: false, error: `${resourceType} not found` };
  }

  return { valid: true, resource };
};

const validateCommentInput = ({
  resourceId,
  resourceType,
  userId,
  comment,
}) => {
  if (!resourceId || !resourceType || !userId || !comment?.trim()) {
    return {
      valid: false,
      error: "resourceId, resourceType, userId, and comment are required",
    };
  }

  const validResourceTypes = ["Order", "Product", "Customer"];
  if (!validResourceTypes.includes(resourceType)) {
    return { valid: false, error: `Invalid resourceType: ${resourceType}` };
  }

  return { valid: true };
};

const validateCommentFetchInput = ({ resourceId, resourceType }) => {
  if (!resourceId || !resourceType) {
    return {
      valid: false,
      error: "resourceId and resourceType are required",
    };
  }

  const validResourceTypes = ["Order", "Product", "Customer"];
  if (!validResourceTypes.includes(resourceType)) {
    return { valid: false, error: `Invalid resourceType: ${resourceType}` };
  }

  return { valid: true };
};

// Get comments (no notification needed)
exports.getComments = async (req, res) => {
  try {
    const { resourceId, resourceType, page = 1, limit = 10 } = req.query;

    const inputValidation = validateCommentFetchInput({
      resourceId,
      resourceType,
    });
    if (!inputValidation.valid) {
      return sendErrorResponse(res, 400, inputValidation.error);
    }

    const resourceValidation = await validateResource(resourceId, resourceType);
    if (!resourceValidation.valid) {
      return sendErrorResponse(res, 404, resourceValidation.error);
    }

    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    if (isNaN(pageNum) || pageNum < 1) {
      return sendErrorResponse(res, 400, "Invalid page number");
    }
    if (isNaN(limitNum) || limitNum < 1 || limitNum > 100) {
      return sendErrorResponse(res, 400, "Invalid limit (must be 1-100)");
    }

    const { comments, totalCount } = await fetchCommentsWithUsers(
      resourceId,
      resourceType,
      pageNum,
      limitNum
    );

    return res.status(200).json({
      comments,
      totalCount,
      page: pageNum,
      limit: limitNum,
    });
  } catch (err) {
    return sendErrorResponse(res, 500, "Failed to fetch comments", err.message);
  }
};

const fetchCommentsWithUsers = async (
  resourceId,
  resourceType,
  pageNum,
  limitNum
) => {
  const comments = await Comment.find({ resourceId, resourceType })
    .sort({ createdAt: -1 })
    .skip((pageNum - 1) * limitNum)
    .limit(limitNum)
    .lean();

  const commentsWithUsers = await Promise.all(
    comments.map(async (comment) => {
      const user = await User.findOne({
        where: { userId: String(comment.userId) },
        attributes: ["userId", "username", "name"],
      });
      return {
        ...comment,
        user: user ? user.toJSON() : null,
      };
    })
  );

  const totalCount = await Comment.countDocuments({ resourceId, resourceType });

  return { comments: commentsWithUsers, totalCount };
};

// Add a comment

exports.addComment = async (req, res) => {
  try {
    const { resourceId, resourceType, userId: rawUserId, comment } = req.body;

    // 1. Normalize userId
    const userId = String(rawUserId || "").trim();
    if (!userId || userId === "null" || userId === "undefined") {
      return sendErrorResponse(res, 400, "userId is required and must be valid");
    }

    // 2. Input validation
    const inputValidation = validateCommentInput({
      resourceId,
      resourceType,
      userId,
      comment,
    });
    if (!inputValidation.valid) {
      return sendErrorResponse(res, 400, inputValidation.error);
    }

    // 3. Try to get user — but NEVER fail the request if missing
    let user = null;
    try {
      user = await User.findOne({
        where: { userId },
        attributes: ["userId", "username", "name"],
      });
    } catch (dbErr) {
      console.error("MySQL lookup error in addComment:", {
        userId,
        error: dbErr.message,
      });
    }

    if (!user) {
      console.warn(`User not found in MySQL (proceeding) - userId: ${userId}`);
    }

    // 4. Resource must exist
    const resourceValidation = await validateResource(resourceId, resourceType);
    if (!resourceValidation.valid) {
      return sendErrorResponse(res, 404, resourceValidation.error);
    }

    // 5. Comment limit
    const hasReachedLimit = await Comment.hasReachedCommentLimit(
      resourceId,
      resourceType,
      userId
    );
    if (hasReachedLimit) {
      return sendErrorResponse(
        res,
        400,
        `Max 3 comments allowed on this ${resourceType.toLowerCase()}`
      );
    }

    // 6. Sanitize
    const sanitizedComment = sanitizeHtml(comment.trim(), {
      allowedTags: [],
      allowedAttributes: {},
    });
    if (!sanitizedComment) {
      return sendErrorResponse(res, 400, "Comment cannot be empty");
    }

    // 7. Save to MongoDB with snapshot
    const newComment = await Comment.create({
      resourceId,
      resourceType,
      userId,
      comment: sanitizedComment,
      userSnapshot: {
        name: user?.name || "Unknown User",
        username: user?.username || null,
      },
    });

    // 8. Build response (always has user object)
    const populatedComment = {
      ...newComment.toObject(),
      user: user
        ? {
            userId: user.userId,
            username: user.username,
            name: user.name,
          }
        : {
            userId,
            username: null,
            name: newComment.userSnapshot?.name || "Unknown User",
          },
    };

    // 9. Notifications with fallback name
    if (resourceType === "Order") {
      const order = await Order.findByPk(resourceId);
      if (order) {
        const senderName = user?.name || "Someone";

        const recipientIds = new Set(
          [order.createdFor, order.createdBy, order.assignedUserId, order.secondaryUserId]
            .filter(Boolean)
        );

        for (const recipientId of recipientIds) {
          await sendNotification({
            userId: recipientId,
            title: `New Comment on Order #${order.orderNo}`,
            message: `${senderName} commented: "${sanitizedComment}"`,
          });
        }
      }
    }

    // 10. Success — always 201
    return res.status(201).json({
      message: "Comment added successfully",
      comment: populatedComment,
    });
  } catch (err) {
    console.error("Critical error in addComment:", {
      message: err.message,
      stack: err.stack,
      body: req.body,
    });

    return sendErrorResponse(res, 500, "Failed to add comment", err.message);
  }
};

// Delete comments by resource
exports.deleteCommentsByResource = async (req, res) => {
  try {
    const { resourceId, resourceType } = req.body;

    const inputValidation = validateCommentInput({ resourceId, resourceType });
    if (!inputValidation.valid) {
      return sendErrorResponse(res, 400, inputValidation.error);
    }

    const resourceValidation = await validateResource(resourceId, resourceType);
    if (!resourceValidation.valid) {
      return sendErrorResponse(res, 404, resourceValidation.error);
    }

    const result = await Comment.deleteMany({ resourceId, resourceType });

    // Send notification to admin
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Comments Deleted for ${resourceType}`,
      message: `${result.deletedCount} comments deleted for ${resourceType} ID ${resourceId}`,
    });

    return res.status(200).json({
      message: `Deleted ${result.deletedCount} comments for ${resourceType}`,
    });
  } catch (err) {
    return sendErrorResponse(
      res,
      500,
      "Failed to delete comments",
      err.message
    );
  }
};

// Delete a comment
exports.deleteComment = async (req, res) => {
  try {
    const { commentId } = req.params;
    const { userId } = req.body;

    const comment = await Comment.findById(commentId);
    if (!comment) {
      return sendErrorResponse(res, 404, "Comment not found");
    }

    if (comment.userId !== userId) {
      return sendErrorResponse(res, 403, "Unauthorized to delete this comment");
    }

    // Send notification to admin
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Comment Deleted on ${comment.resourceType}`,
      message: `Comment on ${comment.resourceType} ID ${comment.resourceId} by user ${userId} has been deleted: "${comment.comment}"`,
    });

    await Comment.findByIdAndDelete(commentId);

    return res.status(200).json({
      message: "Comment deleted successfully",
    });
  } catch (err) {
    return sendErrorResponse(res, 500, "Failed to delete comment", err.message);
  }
};

/**
 * Compute totals (GST, extra discount, final amount, amountPaid validation)
 * @returns {{gstValue, extraDiscountValue, subTotal, finalTotal}}
 */
function computeTotals({
  products = [],
  shipping = 0,
  gst = 0,
  extraDiscount = 0,
  extraDiscountType = "fixed",
  amountPaid = 0,
}) {
  // 1. Sub-total (price * qty after line-discount)
  const subTotal = products.reduce((sum, p) => sum + (p.total ?? 0), 0);

  // 2. Shipping
  const totalWithShipping = subTotal + Number(shipping);

  // 3. GST
  const gstValue = (totalWithShipping * Number(gst)) / 100;

  // 4. Extra discount
  let extraDiscountValue = 0;
  if (extraDiscount > 0) {
    extraDiscountValue =
      extraDiscountType === "percent"
        ? (totalWithShipping * Number(extraDiscount)) / 100
        : Number(extraDiscount);
  }

  // 5. **FINAL AMOUNT**
  const finalAmount = totalWithShipping + gstValue - extraDiscountValue;

  // // 6. amountPaid must not exceed final amount
  // if (Number(amountPaid) > finalAmount + 0.01) {
  //   throw new Error(
  //     `amountPaid (${amountPaid}) cannot exceed final amount (${finalAmount.toFixed(
  //       2
  //     )})`
  //   );
  // }

  return {
    subTotal,
    totalWithShipping,
    gstValue,
    extraDiscountValue,
    finalAmount, // <-- NEW
  };
}
// ─────────────────────────────────────────────────────────────
// Helper: Generate next daily sequential orderNo (DDMMYY101, etc.)
// ─────────────────────────────────────────────────────────────
async function generateDailyOrderNumber(t) {
  const todayStart = moment().startOf("day").toDate();
  const todayEnd = moment().endOf("day").toDate();
  const prefix = moment().format("DDMMYY"); // e.g. 150126

  let attempt = 0;
  const MAX_ATTEMPTS = 15;

  while (attempt < MAX_ATTEMPTS) {
    attempt++;

    // Find the highest sequence today
    const lastOrder = await Order.findOne({
      where: {
        orderNo: {
          [Op.like]: `${prefix}%`,
        },
        createdAt: {
          [Op.between]: [todayStart, todayEnd],
        },
      },
      attributes: ["orderNo"],
      order: [["orderNo", "DESC"]],
      limit: 1,
      transaction: t,
      lock: t.LOCK.UPDATE, // reduces race window
    });

    let nextSeq = 101;

    if (lastOrder) {
      const lastSeqStr = lastOrder.orderNo.slice(prefix.length);
      const parsed = parseInt(lastSeqStr, 10);
      if (!isNaN(parsed)) {
        nextSeq = parsed + 1;
      }
    }

    const candidate = `${prefix}${nextSeq}`;

    // Final collision check
    const conflict = await Order.findOne({
      where: { orderNo: candidate },
      transaction: t,
    });

    if (!conflict) {
      return candidate;
    }

    console.warn(
      `Order number collision: ${candidate} — retrying (${attempt}/${MAX_ATTEMPTS})`
    );
  }

  throw new Error(
    `Failed to generate unique order number after ${MAX_ATTEMPTS} attempts`
  );
}
/**
 * Reduce stock + log history (shared by create & update)
 */
async function reduceStockAndLog({
  productUpdates,
  createdBy,
  orderNo,
  customMessage,
  transaction,
}) {
  if (!transaction) throw new Error("Transaction is required");

  const username =
    (
      await User.findByPk(createdBy, {
        attributes: ["username"],
        transaction,
      })
    )?.username || "System";

  const autoMsg = `Stock removed by ${username} (Order #${orderNo})`;
  const msg = customMessage?.trim() ? `${customMessage} (${autoMsg})` : autoMsg;

  for (const upd of productUpdates) {
    const { productId, quantityToReduce, productRecord } = upd;

    if (quantityToReduce <= 0) continue; // safety

    const newQty = productRecord.quantity - quantityToReduce;

    // 1. Update product quantity
    await Product.update(
      { quantity: newQty },
      { where: { productId }, transaction }
    );

    // Inside the loop in reduceStockAndLog:
    await InventoryHistory.create(
      {
        id: uuidv7(), // ← Explicitly set the ID here!
        productId,
        change: -quantityToReduce,
        quantityAfter: newQty,
        action: "sale",
        orderNo: String(orderNo),
        userId: createdBy,
        message: msg,
      },
      { transaction }
    );

    // 3. Update status if needed
    let newStatus = "active";
    if (newQty === 0) {
      newStatus = "out_of_stock";
    } else if (
      productRecord.alert_quantity != null &&
      newQty <= productRecord.alert_quantity
    ) {
      newStatus = "low_stock";
    }

    if (newStatus !== productRecord.status) {
      await Product.update(
        { status: newStatus },
        { where: { productId }, transaction }
      );
    }
  }
}
/**
 * Restore stock when order is canceled / deleted
 */
async function restoreStock({ products, orderNo }) {
  if (!products?.length) return;

  for (const p of products) {
    const prod = await Product.findByPk(p.id || p.productId);
    if (!prod) continue;

    const qtyToAdd = p.quantity ?? 0;
    const newQty = prod.quantity + qtyToAdd;

    await Product.update(
      { quantity: newQty },
      { where: { productId: prod.productId } }
    );

    await InventoryHistory.create({
      productId: prod.productId,
      change: qtyToAdd,
      quantityAfter: newQty,
      action: "add-stock",
      orderNo,
      message: `Stock restored (order #${orderNo} cancelled/deleted)`,
    });
  }
}

// ──────── CREATE ORDER ────────
// ──────── CREATE ORDER ────────
// ──────── CREATE ORDER – FINAL MYSQL-ONLY VERSION ────────
// ──────── CREATE ORDER – FINAL FIXED & SAFE VERSION ────────
exports.createOrder = async (req, res) => {
  const t = await sequelize.transaction();

  try {
    const {
      createdFor,
      createdBy,
      status,
      dueDate,
      assignedTeamId,
      assignedUserId,
      secondaryUserId,
      followupDates,
      source,
      priority,
      description,
      orderNo: rawOrderNo, // ← we will ignore this from client
      quotationId,
      products = [],
      masterPipelineNo,
      previousOrderNo,
      shipTo,
      shipping = 0,
      message: customMessage,
      gst = null,
      extraDiscount = null,
      extraDiscountType = "fixed",
      amountPaid = 0,
    } = req.body;

    // ── BASIC REQUIRED FIELDS ──
    if (!createdFor || !createdBy) {
      return sendErrorResponse(
        res,
        400,
        "createdFor and createdBy are required"
      );
    }

    // ── VALIDATE USERS & CUSTOMER ──
    const [creator, customer] = await Promise.all([
      User.findByPk(createdBy, {
        attributes: ["userId", "username", "name"],
        transaction: t,
      }),
      Customer.findByPk(createdFor, { transaction: t }),
    ]);

    if (!creator) return sendErrorResponse(res, 404, "Creator user not found");
    if (!customer) return sendErrorResponse(res, 404, "Customer not found");

    // ── OPTIONAL REFERENCES VALIDATION ──
    if (quotationId) {
      const q = await Quotation.findByPk(quotationId, { transaction: t });
      if (!q) return sendErrorResponse(res, 404, "Quotation not found");
    }
    if (masterPipelineNo) {
      const m = await Order.findOne({
        where: { orderNo: masterPipelineNo },
        transaction: t,
      });
      if (!m)
        return sendErrorResponse(
          res,
          404,
          `Master order ${masterPipelineNo} not found`
        );
      if (masterPipelineNo === orderNo)
        return sendErrorResponse(
          res,
          400,
          "Master cannot be the same as current order"
        );
    }
    if (previousOrderNo) {
      const p = await Order.findOne({
        where: { orderNo: previousOrderNo },
        transaction: t,
      });
      if (!p)
        return sendErrorResponse(
          res,
          404,
          `Previous order ${previousOrderNo} not found`
        );
    }

    // ── PRODUCTS VALIDATION + STOCK CHECK ──
    let productUpdates = [];
    if (products.length > 0) {
      if (!Array.isArray(products))
        return sendErrorResponse(res, 400, "Products must be an array");

      for (const p of products) {
        const {
          id,
          price,
          discount = 0,
          total,
          quantity,
          discountType = "percent",
        } = p;

        if (
          !id ||
          !quantity ||
          quantity < 1 ||
          price == null ||
          total == null
        ) {
          return sendErrorResponse(
            res,
            400,
            "Each product must have id, quantity ≥ 1, price, and total"
          );
        }

        const prod = await Product.findByPk(id, {
          lock: t.LOCK.UPDATE,
          transaction: t,
        });
        if (!prod)
          return sendErrorResponse(res, 404, `Product not found: ${id}`);

        // Validate line total
        const calculatedTotal =
          discountType === "percent"
            ? price * (1 - discount / 100) * quantity
            : (price - discount) * quantity;

        if (Math.abs(total - calculatedTotal) > 0.01) {
          return sendErrorResponse(
            res,
            400,
            `Invalid total for product ${id}. Expected ~${calculatedTotal.toFixed(
              2
            )}`
          );
        }

        if (prod.quantity < quantity) {
          return sendErrorResponse(
            res,
            400,
            `Insufficient stock for ${prod.name}. Available: ${prod.quantity}, Required: ${quantity}`
          );
        }

        productUpdates.push({
          productId: id,
          quantityToReduce: quantity,
          productRecord: prod,
        });
      }
    }

    // ── FINANCIAL CALCULATIONS ──
    const parsedShipping = parseFloat(shipping) || 0;
    const parsedGst = gst !== null && gst !== "" ? parseFloat(gst) : null;
    const parsedExtraDiscount =
      extraDiscount !== null && extraDiscount !== ""
        ? parseFloat(extraDiscount)
        : null;
    const finalDiscountType =
      parsedExtraDiscount !== null ? extraDiscountType : null;
    const parsedAmountPaid = parseFloat(amountPaid) || 0;

    const { gstValue, extraDiscountValue, finalAmount } = computeTotals({
      products,
      shipping: parsedShipping,
      gst: parsedGst,
      extraDiscount: parsedExtraDiscount,
      extraDiscountType: finalDiscountType,
    });

    // ── PRIORITY & STATUS VALIDATION ──
    const priorityLower = priority ? priority.toLowerCase() : "medium";
    if (!VALID_PRIORITIES.includes(priorityLower)) {
      return sendErrorResponse(res, 400, `Invalid priority: ${priority}`);
    }
    const statusUpper = status ? status.toUpperCase() : "PREPARING";
    if (!VALID_STATUSES.includes(statusUpper)) {
      return sendErrorResponse(res, 400, `Invalid status: ${status}`);
    }

    // ── GENERATE DAILY SEQUENTIAL orderNo (e.g. 150126101) ──
    const orderNo = await generateDailyOrderNumber(t);

    // ── CREATE ORDER (MySQL) ──
    const order = await Order.create(
      {
        createdFor,
        createdBy,
        status: statusUpper,
        dueDate: dueDate || null,
        followupDates: Array.isArray(followupDates)
          ? followupDates.filter(Boolean)
          : null,
        source: source || null,
        priority: priorityLower,
        description: description || null,
        orderNo, // ← generated here!
        quotationId: quotationId || null,
        masterPipelineNo: masterPipelineNo || null,
        previousOrderNo: previousOrderNo || null,
        shipTo: shipTo || null,
        shipping: parsedShipping,
        assignedTeamId: assignedTeamId || null,
        assignedUserId: assignedUserId || null,
        secondaryUserId: secondaryUserId || null,
        gst: parsedGst,
        gstValue,
        extraDiscount: parsedExtraDiscount,
        extraDiscountType: finalDiscountType,
        extraDiscountValue,
        amountPaid: parsedAmountPaid,
        finalAmount,
      },
      { transaction: t }
    );

    // ── REDUCE STOCK & LOG HISTORY (FULLY TRANSACTIONAL) ──
    if (productUpdates.length > 0) {
      await reduceStockAndLog({
        productUpdates,
        createdBy,
        orderNo: order.orderNo,
        customMessage,
        transaction: t,
      });
    }

    // ── COMMIT MYSQL TRANSACTION FIRST ──
    await t.commit();

    // ── SAVE ORDER ITEMS TO MONGODB (AFTER COMMIT – NON-TRANSACTIONAL) ──
    if (products.length > 0) {
      try {
        const dbProducts = await Product.findAll({
          where: { productId: products.map((p) => p.id) },
          attributes: ["productId", "name", "images", "meta", "product_code"],
        });

        const productMap = {};
        dbProducts.forEach((p) => {
          let imageUrl = null;
          if (p.images) {
            try {
              const imgs = JSON.parse(p.images);
              if (Array.isArray(imgs) && imgs.length > 0) imageUrl = imgs[0];
            } catch (_) {}
          }
          productMap[p.productId] = { name: p.name, imageUrl };
        });

        const mongoItems = products.map((p) => {
          const { name = "Unknown", imageUrl = null } = productMap[p.id] || {};
          return {
            productId: p.id,
            name,
            imageUrl,
               productCode: p.product_code || p.code || "",
      companyCode:
        p.meta?.["d11da9f9-3f2e-4536-8236-9671200cca4a"] || null,
            quantity: p.quantity,
            price: p.price,
            discount: p.discount || 0,
            discountType: p.discountType || "percent",
            total: p.total,
          };
        });

        await OrderItem.findOneAndUpdate(
          { orderId: order.id },
          { orderId: order.id, items: mongoItems },
          { upsert: true }
        );
      } catch (mongoErr) {
        console.error(
          "Warning: Failed to save OrderItems to MongoDB:",
          mongoErr.message
        );
        // Don't fail the whole request — order is already created safely
      }
    }

    // ── SEND NOTIFICATIONS (AFTER SUCCESS) ──
    const recipients = new Set(
      [createdBy, assignedUserId, secondaryUserId].filter(Boolean)
    );
    for (const userId of recipients) {
      await sendNotification({
        userId,
        title: `New Order #${order.orderNo}`,
        message: `Order #${order.orderNo} created for ${customer.name}.`,
      });
    }
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `New Order #${order.orderNo}`,
      message: `Order #${order.orderNo} created by ${creator.name} for ${customer.name}.`,
    });

    return res.status(201).json({
      message: "Order created successfully",
      id: order.id,
      orderNo: order.orderNo,
    });
  } catch (err) {
    try {
      await t.rollback();
    } catch (rollbackErr) {
      console.warn("Rollback failed:", rollbackErr.message);
    }

    console.error("Create Order Error:", err);
    return sendErrorResponse(res, 500, "Failed to create order", err.message);
  }
};

// ──────── UPDATE ORDER (by id) ────────
// ──────── UPDATE ORDER (by id) ────────
// ────────────────────────────────
exports.updateOrderById = async (req, res) => {
  try {
    const { id } = req.params;
    const updates = { ...req.body };

    const order = await Order.findByPk(id, {
      include: [
        { model: Customer, as: "customer" },
        { model: Address, as: "shippingAddress" },
      ],
    });

    if (!order) {
      return sendErrorResponse(res, 404, "Order not found");
    }

    // ── STATUS ──
    if (updates.status) {
      const norm = updates.status.toUpperCase();
      if (!VALID_STATUSES.includes(norm)) {
        return sendErrorResponse(res, 400, `Invalid status: ${updates.status}`);
      }
      if (norm === "DISPATCHED" && !order.gatePassLink?.trim()) {
        return sendErrorResponse(
          res,
          400,
          "Gate-pass required before dispatching"
        );
      }
      updates.status = norm;
    }

    // ── PRIORITY ──
    if (updates.priority) {
      const p = updates.priority.toLowerCase();
      if (!VALID_PRIORITIES.includes(p)) {
        return sendErrorResponse(
          res,
          400,
          `Invalid priority: ${updates.priority}`
        );
      }
      updates.priority = p;
    }

    // ── DATES ──
    if (updates.dueDate !== undefined) {
      if (
        updates.dueDate &&
        !moment(updates.dueDate, "YYYY-MM-DD", true).isValid()
      ) {
        return sendErrorResponse(
          res,
          400,
          "Invalid dueDate format (YYYY-MM-DD)"
        );
      }
      updates.dueDate = updates.dueDate || null;
    }

    if (updates.followupDates !== undefined) {
      if (!Array.isArray(updates.followupDates)) {
        return sendErrorResponse(res, 400, "followupDates must be an array");
      }
      const validDates = updates.followupDates.filter(
        (d) => d && moment(d, "YYYY-MM-DD", true).isValid()
      );
      updates.followupDates = validDates.length > 0 ? validDates : null;
    }

    // ── TEAM / USERS ──
    if (updates.assignedTeamId !== undefined) {
      updates.assignedTeamId = updates.assignedTeamId || null;
      if (updates.assignedTeamId) {
        const team = await Team.findByPk(updates.assignedTeamId);
        if (!team)
          return sendErrorResponse(res, 404, "Assigned team not found");
      }
    }

    if (updates.assignedUserId !== undefined) {
      updates.assignedUserId = updates.assignedUserId || null;
      if (updates.assignedUserId) {
        const user = await User.findByPk(updates.assignedUserId);
        if (!user)
          return sendErrorResponse(res, 404, "Assigned user not found");
      }
    }

    if (updates.secondaryUserId !== undefined) {
      updates.secondaryUserId = updates.secondaryUserId || null;
      if (updates.secondaryUserId) {
        const user = await User.findByPk(updates.secondaryUserId);
        if (!user)
          return sendErrorResponse(res, 404, "Secondary user not found");
      }
    }

    // ── ORDER NUMBER ──
    if (updates.orderNo !== undefined) {
      const newNo = parseInt(updates.orderNo);
      if (isNaN(newNo) || newNo <= 0) {
        return sendErrorResponse(res, 400, "orderNo must be a positive number");
      }
      const conflict = await Order.findOne({
        where: { orderNo: newNo, id: { [Op.ne]: id } },
      });
      if (conflict)
        return sendErrorResponse(res, 400, "Order number already exists");
      updates.orderNo = newNo;
    }

    // ── MASTER / PREVIOUS / QUOTATION ──
    if (updates.masterPipelineNo !== undefined) {
      if (!updates.masterPipelineNo) updates.masterPipelineNo = null;
      else {
        const m = await Order.findOne({
          where: { orderNo: updates.masterPipelineNo },
        });
        if (!m) return sendErrorResponse(res, 404, "Master order not found");
        if (updates.masterPipelineNo === order.orderNo) {
          return sendErrorResponse(
            res,
            400,
            "Master cannot be the same as current order"
          );
        }
      }
    }

    if (updates.previousOrderNo !== undefined) {
      if (!updates.previousOrderNo) updates.previousOrderNo = null;
      else {
        const p = await Order.findOne({
          where: { orderNo: updates.previousOrderNo },
        });
        if (!p) return sendErrorResponse(res, 404, "Previous order not found");
        if (updates.previousOrderNo === order.orderNo) {
          return sendErrorResponse(
            res,
            400,
            "Previous cannot be the same as current order"
          );
        }
      }
    }

    if (updates.quotationId !== undefined) {
      updates.quotationId = updates.quotationId || null;
      if (updates.quotationId) {
        const q = await Quotation.findByPk(updates.quotationId);
        if (!q) return sendErrorResponse(res, 404, "Quotation not found");
      }
    }

    // ── PRODUCTS (FULL REPLACE) ──
    let newProductUpdates = [];

    if (updates.products !== undefined) {
      if (updates.products === null || updates.products === "") {
        updates.products = [];
      } else if (!Array.isArray(updates.products)) {
        return sendErrorResponse(res, 400, "products must be an array");
      }

      for (const p of updates.products) {
        const {
          id,
          price,
          quantity,
          total,
          discount = 0,
          discountType, // ← optional
        } = p;

        if (
          !id ||
          price == null ||
          quantity == null ||
          total == null ||
          quantity < 1
        ) {
          return sendErrorResponse(
            res,
            400,
            "Each product needs id, price, quantity, and total"
          );
        }

        const prod = await Product.findByPk(id);
        if (!prod)
          return sendErrorResponse(res, 404, `Product not found: ${id}`);

        const finalDiscountType =
          discountType || prod.discountType || "percent";
        const calculatedTotal =
          finalDiscountType === "percent"
            ? price * (1 - discount / 100) * quantity
            : (price - discount) * quantity;

        if (Math.abs(total - calculatedTotal) > 0.01) {
          return sendErrorResponse(
            res,
            400,
            `Invalid total for product ${id}. Expected ${calculatedTotal.toFixed(
              2
            )}`
          );
        }

        const oldQty = order.products?.find((x) => x.id === id)?.quantity || 0;
        if (prod.quantity + oldQty < quantity) {
          return sendErrorResponse(
            res,
            400,
            `Insufficient stock for ${prod.name}`
          );
        }

        newProductUpdates.push({
          productId: id,
          quantityToReduce: quantity,
          productRecord: prod,
        });
      }
    }

    // ── FINANCIAL FIELDS ──
    if (updates.shipping !== undefined) {
      const s = parseFloat(updates.shipping) || 0;
      if (s < 0) return sendErrorResponse(res, 400, "Invalid shipping");
      updates.shipping = s;
    }

    if (updates.gst !== undefined) {
      const g = updates.gst === "" ? null : parseFloat(updates.gst);
      if (g !== null && (isNaN(g) || g < 0 || g > 100)) {
        return sendErrorResponse(res, 400, "GST must be 0–100");
      }
      updates.gst = g;
    }

    if (updates.extraDiscount !== undefined) {
      // Allow: null, undefined, empty string → treat as no discount (null)
      if (
        updates.extraDiscount === null ||
        updates.extraDiscount === undefined ||
        updates.extraDiscount === ""
      ) {
        updates.extraDiscount = null;
        updates.extraDiscountType = null; // optional: clear type too
      } else {
        const parsed = parseFloat(updates.extraDiscount);
        if (isNaN(parsed) || parsed < 0) {
          return sendErrorResponse(
            res,
            400,
            "Extra discount must be a positive number or zero"
          );
        }
        updates.extraDiscount = parsed;
      }
    }

    if (updates.extraDiscountType !== undefined) {
      if (updates.extraDiscount == null || updates.extraDiscount === 0) {
        updates.extraDiscountType = null;
      } else if (!["fixed", "percent"].includes(updates.extraDiscountType)) {
        return sendErrorResponse(
          res,
          400,
          "extraDiscountType must be 'fixed' or 'percent'"
        );
      }
    }
    if (updates.amountPaid !== undefined) {
      const a = parseFloat(updates.amountPaid) || 0;
      if (isNaN(a) || a < 0)
        return sendErrorResponse(res, 400, "Invalid amountPaid");
      updates.amountPaid = a;
    }

    // ── RECALCULATE TOTALS ──
    const calcInput = {
      products: updates.products ?? order.products ?? [],
      shipping: updates.shipping ?? order.shipping ?? 0,
      gst: updates.gst ?? order.gst ?? 0,
      extraDiscount: updates.extraDiscount ?? order.extraDiscount ?? 0,
      extraDiscountType:
        updates.extraDiscountType ?? order.extraDiscountType ?? "fixed",
      amountPaid: updates.amountPaid ?? order.amountPaid ?? 0,
    };

    const { gstValue, extraDiscountValue, finalAmount } =
      computeTotals(calcInput);
    updates.gstValue = gstValue;
    updates.extraDiscountValue = extraDiscountValue;
    updates.finalAmount = finalAmount;

    // ── STOCK: Restore old → Deduct new ──
    if (newProductUpdates.length > 0) {
      if (order.products && order.products.length > 0) {
        await restoreStock({
          products: order.products,
          orderNo: order.orderNo,
        });
      }
      await reduceStockAndLog({
        productUpdates: newProductUpdates,
        createdBy: order.createdBy,
        orderNo: order.orderNo,
      });
    }

    // ── SAVE TO MYSQL ──
    await order.update(updates);
    await order.reload();

    // ── UPDATE MONGODB ORDER ITEMS (only if products changed) ──
    if (updates.products && updates.products.length > 0) {
      const productIds = updates.products
        .map((p) => p.id || p.productId)
        .filter(Boolean);

      const dbProducts = await Product.findAll({
        where: { productId: productIds },
        attributes: ["productId", "name", "images"],
      });

      const productMap = {};
      dbProducts.forEach((p) => {
        let imageUrl = null;
        if (p.images) {
          try {
            const imgs = JSON.parse(p.images);
            if (Array.isArray(imgs) && imgs.length > 0) imageUrl = imgs[0];
          } catch (e) {}
        }
        productMap[p.productId] = {
          name: p.name || "Unknown Product",
          imageUrl,
        };
      });

      const mongoItems = updates.products.map((p) => {
        const id = p.id || p.productId;
        const { name, imageUrl } = productMap[id] || {
          name: "Unknown Product",
          imageUrl: null,
        };
        return {
          productId: id,
          name,
          imageUrl,
          quantity: p.quantity,
          price: p.price,
          discount: p.discount ?? 0,
          discountType: p.discountType || "percent",
          tax: 0,
          total: p.total,
        };
      });

      await OrderItem.findOneAndUpdate(
        { orderId: order.id },
        { orderId: order.id, items: mongoItems },
        { upsert: true }
      );
    }

    // ── NOTIFICATIONS ──
    const customerName = order.customer?.name || "Customer";
    const addr = order.shippingAddress
      ? `, ship to ${order.shippingAddress.street || ""}`
      : "";

    const recipients = new Set(
      [
        order.createdBy,
        updates.assignedUserId ?? order.assignedUserId,
        updates.secondaryUserId ?? order.secondaryUserId,
      ].filter(Boolean)
    );

    for (const uid of recipients) {
      await sendNotification({
        userId: uid,
        title: `Order Updated #${order.orderNo}`,
        message: `Order #${order.orderNo} for ${customerName}${addr} updated.`,
      });
    }

    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Order #${order.orderNo} Updated`,
      message: `Order updated by ${req.user?.name || "someone"}.`,
    });

    return res.status(200).json({
      message: "Order updated successfully",
      order,
    });
  } catch (err) {
    console.error("Update Order Error:", err);
    return sendErrorResponse(res, 500, "Failed to update order", err.message);
  }
};

// ──────── UPDATE STATUS ONLY ────────
// ──────── UPDATE STATUS ONLY ────────
exports.updateOrderStatus = async (req, res) => {
  try {
    const { id, status } = req.body;
    if (!id || !status)
      return sendErrorResponse(res, 400, "id & status required");

    const order = await Order.findByPk(id, {
      include: [{ model: Customer, as: "customer" }],
    });
    if (!order) return sendErrorResponse(res, 404, "Order not found");

    const norm = status.toUpperCase();
    if (!VALID_STATUSES.includes(norm))
      return sendErrorResponse(res, 400, `Invalid status: ${status}`);

    // GATE-PASS REQUIRED FOR DISPATCHED
    if (norm === "DISPATCHED" && !order.gatePassLink) {
      return sendErrorResponse(
        res,
        400,
        "Gate-pass must be uploaded before dispatching the order"
      );
    }

    const oldStatus = order.status;
    order.status = norm;
    await order.save();

    // Restore stock on CANCELED / CLOSED
    if (["CANCELED", "CLOSED"].includes(norm) && order.products?.length) {
      await restoreStock({ products: order.products, orderNo: order.orderNo });
    }

    // ── NOTIFICATIONS ──
    const recipients = new Set(
      [order.createdBy, order.assignedUserId, order.secondaryUserId].filter(
        Boolean
      )
    );

    for (const uid of recipients) {
      await sendNotification({
        userId: uid,
        title: `Order Status #${order.orderNo}`,
        message: `Order #${order.orderNo} for ${
          order.customer?.name || "Customer"
        } → ${norm}.`,
      });
    }

    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Order Status #${order.orderNo}`,
      message: `Order #${order.orderNo} changed from ${oldStatus} → ${norm}.`,
    });

    return res.status(200).json({ message: "Status updated", order });
  } catch (err) {
    return sendErrorResponse(res, 500, "Failed to update status", err.message);
  }
};
// GET /api/orders/:id/download-invoice
// GET /api/orders/:id/download-invoice
exports.downloadInvoice = async (req, res) => {
  try {
    const { id } = req.params;

    // Fetch only needed fields: orderNo, invoiceLink, and customer name
    const order = await Order.findByPk(id, {
      include: [
        {
          model: Customer,
          as: "customer",
          attributes: ["name"],
        },
      ],
      attributes: ["id", "orderNo", "invoiceLink"],
    });

    if (!order) {
      return sendErrorResponse(res, 404, "Order not found");
    }

    if (!order.invoiceLink) {
      return sendErrorResponse(res, 404, "No invoice attached to this order");
    }

    // Optional: Authorization check (uncomment if needed)
    // const allowedUsers = [order.createdBy, order.assignedUserId, order.secondaryUserId].filter(Boolean);
    // if (!allowedUsers.includes(req.user.userId) && req.user.role !== 'admin') {
    //   return sendErrorResponse(res, 403, "Unauthorized to download invoice");
    // }

    const invoiceUrl = order.invoiceLink; // Already full URL — no need to modify

    // Fetch the PDF
    const response = await fetch(invoiceUrl);

    if (!response.ok) {
      console.error(
        `Failed to fetch invoice: ${response.status} ${response.statusText}`
      );
      return sendErrorResponse(
        res,
        502,
        "Unable to retrieve invoice from storage"
      );
    }

    // Generate clean, professional filename
    const customerName = order.customer?.name || "Customer";
    const cleanName = customerName
      .replace(/[^a-zA-Z0-9]/g, "_") // Replace special chars with _
      .substring(0, 30); // Limit length

    const filename = `INVOICE #${order.orderNo} for ${cleanName}.pdf`;

    // Set headers to force download with correct name
    res.set({
      "Content-Type": "application/pdf",
      "Content-Disposition": `attachment; filename="${filename}"`,
      "Cache-Control": "no-cache, no-store, must-revalidate",
      Pragma: "no-cache",
      Expires: "0",
    });

    // Stream the file directly to client
    await pipe(response.body, res);

    // Log success
    console.log(`Invoice downloaded: ${filename} (Order #${order.orderNo})`);
  } catch (err) {
    console.error("downloadInvoice error:", err);
    return sendErrorResponse(res, 500, "Failed to download invoice");
  }
};
// ──────── DELETE ORDER ────────
exports.deleteOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const order = await Order.findByPk(id, {
      include: [{ model: Customer, as: "customer" }],
    });
    if (!order) return sendErrorResponse(res, 404, "Order not found");

    // prevent delete if referenced
    const deps = await Order.findAll({
      where: {
        [Op.or]: [
          { previousOrderNo: order.orderNo },
          { masterPipelineNo: order.orderNo },
        ],
      },
    });
    if (deps.length)
      return sendErrorResponse(
        res,
        400,
        "Order referenced by other orders – cannot delete"
      );

    // restore stock
    if (order.products?.length) {
      await restoreStock({ products: order.products, orderNo: order.orderNo });
    }

    // notifications
    const recipients = new Set(
      [order.createdBy, order.assignedUserId, order.secondaryUserId].filter(
        Boolean
      )
    );
    for (const uid of recipients) {
      await sendNotification({
        userId: uid,
        title: `Order Deleted #${order.orderNo}`,
        message: `Order #${order.orderNo} for ${
          order.customer?.name || "Customer"
        } deleted.`,
      });
    }
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Order Deleted #${order.orderNo}`,
      message: `Order #${order.orderNo} deleted.`,
    });

    // mongo clean-up
    await Comment.deleteMany({ resourceId: id, resourceType: "Order" });
    await OrderItem.deleteMany({ orderId: id });

    await order.destroy();
    return res.status(200).json({ message: "Order deleted" });
  } catch (err) {
    return sendErrorResponse(res, 500, "Delete failed", err.message);
  }
};

// ──────── DRAFT ORDER (now also accepts amountPaid) ────────
exports.draftOrder = async (req, res) => {
  try {
    const {
      quotationId,
      assignedTeamId,
      products,
      masterPipelineNo,
      previousOrderNo,
      shipTo,
      amountPaid = 0, // ← NEW
    } = req.body;

    if (!assignedTeamId)
      return sendErrorResponse(res, 400, "assignedTeamId required");

    const team = await Team.findByPk(assignedTeamId);
    if (!team) return sendErrorResponse(res, 400, "Team not found");

    // optional validations (same as create)
    if (quotationId) {
      const q = await Quotation.findByPk(quotationId);
      if (!q) return sendErrorResponse(res, 400, "Quotation not found");
    }
    if (masterPipelineNo) {
      const m = await Order.findOne({ where: { orderNo: masterPipelineNo } });
      if (!m)
        return sendErrorResponse(
          res,
          404,
          `Master order ${masterPipelineNo} not found`
        );
    }
    if (previousOrderNo) {
      const p = await Order.findOne({ where: { orderNo: previousOrderNo } });
      if (!p)
        return sendErrorResponse(
          res,
          404,
          `Previous order ${previousOrderNo} not found`
        );
    }
    if (shipTo) {
      const a = await Address.findByPk(shipTo);
      if (!a) return sendErrorResponse(res, 404, `Address ${shipTo} not found`);
    }

    // product validation (same as create, but **no stock reduction**)
    if (products) {
      if (!Array.isArray(products) || !products.length)
        return sendErrorResponse(res, 400, "products must be non-empty array");
      for (const p of products) {
        const { id, price, discount, total } = p;
        if (!id || price == null || discount == null || total == null)
          return sendErrorResponse(
            res,
            400,
            "Each product needs id,price,discount,total"
          );
        const prod = await Product.findByPk(id);
        if (!prod)
          return sendErrorResponse(res, 404, `Product ${id} not found`);
        // line-total check
        // Use discountType from payload if exists, else fall back to DB
        const discType = p.discountType || prod.discountType || "percent";
        const expected =
          discType === "percent"
            ? price * (1 - discount / 100)
            : price - discount;
        if (Math.abs(total - expected) > 0.01)
          return sendErrorResponse(
            res,
            400,
            `Invalid total for ${id}. Expected ${expected.toFixed(2)}`
          );
      }
    }

    // amountPaid validation (must be 0 for draft – optional)
    const paid = parseFloat(amountPaid);
    if (isNaN(paid) || paid < 0)
      return sendErrorResponse(res, 400, "Invalid amountPaid");
    if (paid > 0)
      return sendErrorResponse(
        res,
        400,
        "amountPaid must be 0 for draft orders"
      );

    // generate orderNo (same pattern as create)
    const today = moment().format("DDMMYYYY");
    const dayCount = await Order.count({
      where: {
        createdAt: {
          [Op.gte]: moment().startOf("day").toDate(),
          [Op.lte]: moment().endOf("day").toDate(),
        },
      },
    });
    const serial = String(dayCount + 1).padStart(5, "0");
    const orderNo = `${today}${serial}`;

    const order = await Order.create({
      quotationId,
      status: "DRAFT",
      assignedTeamId,
      products,
      masterPipelineNo,
      previousOrderNo,
      orderNo: parseInt(orderNo),
      shipTo,
      amountPaid: 0,
    });

    // admin + team notifications
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Draft Order #${orderNo}`,
      message: `Draft order #${orderNo} created.`,
    });
    const members = await User.findAll({
      include: [{ model: Team, as: "teams", where: { id: assignedTeamId } }],
      attributes: ["userId", "name"],
    });
    for (const m of members) {
      await sendNotification({
        userId: m.userId,
        title: `Draft Assigned #${orderNo}`,
        message: `Draft order #${orderNo} assigned to your team.`,
      });
    }

    return res.status(201).json({ message: "Draft created", order });
  } catch (err) {
    return sendErrorResponse(res, 500, "Draft failed", err.message);
  }
};

// Get all orders (no notification needed)

exports.getAllOrders = async (req, res) => {
  try {
    const { page = 1, limit = 20, search = "", status, priority } = req.query;

    const pageNum = parseInt(page, 10);
    const limitNum = parseInt(limit, 10);
    const offset = (pageNum - 1) * limitNum;

    // Build the where condition dynamically
    const where = {};

    // Status filter (exact match)
    if (status && status.trim() !== "") {
      where.status = status.trim();
    }

    // Priority filter (exact match)
    if (priority && priority.trim() !== "") {
      where.priority = priority.trim();
    }

    // Search – usually across orderNo + customer name
    if (search && search.trim() !== "") {
      const searchTerm = `%${search.trim()}%`;
      where[Op.or] = [
        { orderNo: { [Op.like]: searchTerm } },
        { "$customer.name$": { [Op.like]: searchTerm } },
        // Optional: add more searchable fields
        // { someOtherField: { [Op.like]: searchTerm } },
      ];
    }

    const { count: totalOrders, rows: orders } = await Order.findAndCountAll({
      where, // ← this was missing!
      include: [
        {
          model: Customer,
          as: "customer",
          attributes: ["customerId", "name"],
        },
        {
          model: User,
          as: "creator",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "assignedUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "secondaryUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: Team,
          as: "assignedTeam",
          attributes: ["id", "teamName"],
        },
        {
          model: Order,
          as: "previousOrder",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "masterOrder",
          attributes: ["id", "orderNo"],
        },
        {
          model: Address,
          as: "shippingAddress",
          attributes: ["addressId"],
        },
      ],
      order: [["createdAt", "DESC"]],
      offset,
      limit: limitNum,
      subQuery: false,
    });

    const totalPages = Math.ceil(totalOrders / limitNum);

    return res.status(200).json({
      data: orders.map((order) => order.toJSON()),
      pagination: {
        total: totalOrders,
        page: pageNum,
        limit: limitNum,
        totalPages,
      },
    });
  } catch (err) {
    console.error("getAllOrders error:", err);
    return sendErrorResponse(
      res,
      500,
      "Failed to fetch orders",
      process.env.NODE_ENV === "development" ? err.message : undefined
    );
  }
};
// Get order details (no notification needed)
exports.getOrderDetails = async (req, res) => {
  const { id } = req.params;

  try {
    const order = await Order.findByPk(id, {
      include: [
        {
          model: Customer,
          as: "customer",
          attributes: ["customerId", "name"],
        },
        {
          model: User,
          as: "creator",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "assignedUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "secondaryUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: Team,
          as: "assignedTeam",
          attributes: ["id", "teamName"],
        },
        {
          model: Order,
          as: "previousOrder",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "masterOrder",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "nextOrders",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "pipelineOrders",
          attributes: ["id", "orderNo"],
        },
        {
          model: Address,
          as: "shippingAddress",
          attributes: ["addressId"],
        },
        {
          model: Quotation,
          as: "quotation",
          attributes: [
            "quotationId",
            "document_title",
            "quotation_date",
            "due_date",
            "followupDates",
            "reference_number",
            "products",
            "discountAmount",
            "roundOff",
            "finalAmount",
            "signature_name",
            "signature_image",
            "createdBy",
            "customerId",
            "shipTo",
          ],
        },
      ],
    });

    if (!order) {
      return sendErrorResponse(res, 404, `Order with ID ${id} not found`);
    }

    const { comments } = await fetchCommentsWithUsers(id, "Order", 1, 10);
    let orderWithDetails = order.toJSON();

    if (order.quotationId && order.quotation) {
      try {
        let quotationProducts = order.quotation.products || [];
        if (typeof quotationProducts === "string") {
          try {
            quotationProducts = JSON.parse(quotationProducts);
          } catch (parseErr) {
            quotationProducts = [];
          }
        }

        if (!Array.isArray(quotationProducts)) {
          quotationProducts = [];
        }

        const productIds = quotationProducts
          .map((item) => item.productId)
          .filter((id) => id);

        const products = productIds.length
          ? await Product.findAll({
              where: { productId: productIds }, // FIXED
              attributes: [
                "productId",
                "name",
                "description",
                "discountType",
                "meta",
              ],
            })
          : [];

        const productMap = products.reduce((map, product) => {
          map[product.productId] = product.toJSON();
          return map;
        }, {});

        const enrichedProducts = quotationProducts.map((item) => {
          const product = productMap[item.productId] || {};
          const sellingPrice =
            product.meta && product.meta["9ba862ef-f993-4873-95ef-1fef10036aa5"]
              ? product.meta["9ba862ef-f993-4873-95ef-1fef10036aa5"]
              : null;

          return {
            productId: item.productId,
            quantity: item.quantity || 1,
            discount: item.discount || 0,
            tax: item.tax || 0,
            total: item.total || 0,
            sellingPrice,
            productDetails: product,
          };
        });

        orderWithDetails.products = enrichedProducts;
        orderWithDetails.quotationDetails = {
          quotationId: order.quotation.quotationId,
          document_title: order.quotation.document_title,
          quotation_date: order.quotation.quotation_date,
          due_date: order.quotation.due_date,
          followupDates: order.quotation.followupDates,
          reference_number: order.quotation.reference_number,
          discountAmount: order.quotation.discountAmount || 0,
          roundOff: order.quotation.roundOff || 0,
          finalAmount: order.quotation.finalAmount || 0,
          signature_name: order.quotation.signature_name,
          signature_image: order.quotation.signature_image,
          createdBy: order.quotation.createdBy,
          customerId: order.quotation.customerId,
          shipTo: order.quotation.shipTo,
          status: order.quotation.status,
        };
      } catch (err) {
        orderWithDetails.products = [];
        orderWithDetails.quotationDetails = null;
      }
    } else if (order.products && Array.isArray(order.products)) {
      const productIds = order.products
        .map((item) => item.id)
        .filter((id) => id);

      const products = productIds.length
        ? await Product.findAll({
            where: { productId: productIds }, // FIXED
            attributes: ["productId", "name", "discountType", "meta"],
          })
        : [];

      const productMap = products.reduce((map, product) => {
        map[product.productId] = product.toJSON();
        return map;
      }, {});

      const enrichedProducts = order.products.map((item) => {
        const product = productMap[item.id] || {};
        const sellingPrice =
          product.meta && product.meta["9ba862ef-f993-4873-95ef-1fef10036aa5"]
            ? product.meta["9ba862ef-f993-4873-95ef-1fef10036aa5"]
            : null;

        return {
          productId: item.id,
          quantity: item.quantity || 1,
          price: item.price || 0,
          discount: item.discount || 0,
          total: item.total || item.price * (item.quantity || 1),
          sellingPrice,
          productDetails: product,
        };
      });

      orderWithDetails.products = enrichedProducts;
    } else {
      orderWithDetails.products = [];
    }

    orderWithDetails.comments = comments;

    return res.status(200).json({ order: orderWithDetails });
  } catch (err) {
    return sendErrorResponse(
      res,
      500,
      "Failed to fetch order details",
      err.message
    );
  }
};

// Get recent orders (no notification needed)
exports.recentOrders = async (req, res) => {
  try {
    const orders = await Order.findAll({
      include: [
        {
          model: Customer,
          as: "customer",
          attributes: ["customerId", "name"],
        },
        {
          model: User,
          as: "creator",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "assignedUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "secondaryUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: Team,
          as: "assignedTeam",
          attributes: ["id", "teamName"],
        },
        {
          model: Order,
          as: "previousOrder",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "masterOrder",
          attributes: ["id", "orderNo"],
        },
      ],
      order: [["createdAt", "DESC"]],
      limit: 20,
    });

    return res.status(200).json({ orders });
  } catch (err) {
    return sendErrorResponse(
      res,
      500,
      "Failed to fetch recent orders",
      err.message
    );
  }
};

// Get order by ID (no notification needed)
exports.orderById = async (req, res) => {
  try {
    const { id } = req.params;

    const order = await Order.findByPk(id, {
      include: [
        {
          model: Customer,
          as: "customer",
          attributes: ["customerId", "name"],
        },
        {
          model: User,
          as: "creator",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "assignedUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: User,
          as: "secondaryUser",
          attributes: ["userId", "username", "name"],
        },
        {
          model: Team,
          as: "assignedTeam",
          attributes: ["id", "teamName"],
        },
        {
          model: Order,
          as: "previousOrder",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "masterOrder",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "nextOrders",
          attributes: ["id", "orderNo"],
        },
        {
          model: Order,
          as: "pipelineOrders",
          attributes: ["id", "orderNo"],
        },
        {
          model: Address,
          as: "shippingAddress",
          attributes: ["addressId"],
        },
      ],
    });

    if (!order) {
      return sendErrorResponse(res, 404, "Order not found");
    }

    const { comments } = await fetchCommentsWithUsers(id, "Order", 1, 10);

    const orderWithComments = {
      ...order.toJSON(),
      comments,
    };

    return res.status(200).json({ order: orderWithComments });
  } catch (err) {
    return sendErrorResponse(res, 500, "Failed to fetch order", err.message);
  }
};

// Get filtered orders (no notification needed)
exports.getFilteredOrders = async (req, res) => {
  try {
    const {
      status,
      priority,
      dueDate,
      createdBy,
      assignedTeamId,
      createdFor,
      search,
      page = 1,
      limit = 10,
      masterPipelineNo,
      previousOrderNo,
      shipTo, // Add shipTo filter
    } = req.query;

    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    if (isNaN(pageNum) || pageNum < 1) {
      return sendErrorResponse(res, 400, "Invalid page number");
    }
    if (isNaN(limitNum) || limitNum < 1 || limitNum > 100) {
      return sendErrorResponse(res, 400, "Invalid limit (must be 1-100)");
    }

    const filters = {};

    if (status) {
      const normalizedStatus = status.toUpperCase();
      const validStatuses = [
        "PREPARING",
        "CHECKING",
        "INVOICE",
        "DISPATCHED",
        "DELIVERED",
        "PARTIALLY_DELIVERED",
        "CANCELED",
        "DRAFT",
        "ONHOLD",
      ];
      if (!validStatuses.includes(normalizedStatus)) {
        return sendErrorResponse(res, 400, `Invalid status: ${status}`);
      }
      filters.status = normalizedStatus;
    }

    if (priority) {
      const normalizedPriority = priority.toLowerCase();
      const validPriorities = ["high", "medium", "low"];
      if (!validPriorities.includes(normalizedPriority)) {
        return sendErrorResponse(res, 400, `Invalid priority: ${priority}`);
      }
      filters.priority = normalizedPriority;
    }

    if (dueDate) {
      const parsedDate = new Date(dueDate);
      if (isNaN(parsedDate)) {
        return sendErrorResponse(res, 400, "Invalid dueDate format");
      }
      filters.dueDate = parsedDate;
    }

    if (createdBy) {
      const user = await User.findByPk(createdBy);
      if (!user) {
        return sendErrorResponse(res, 404, "Creator user not found");
      }
      filters.createdBy = createdBy;
    }

    if (assignedTeamId) {
      const team = await Team.findByPk(assignedTeamId);
      if (!team) {
        return sendErrorResponse(res, 404, "Assigned team not found");
      }
      filters.assignedTeamId = assignedTeamId;
    }

    if (createdFor) {
      const customer = await Customer.findByPk(createdFor);
      if (!customer) {
        return sendErrorResponse(res, 404, "Customer not found");
      }
      filters.createdFor = createdFor;
    }

    if (masterPipelineNo) {
      const masterOrder = await Order.findOne({
        where: { orderNo: masterPipelineNo },
      });
      if (!masterOrder) {
        return sendErrorResponse(
          res,
          404,
          `Master order with orderNo ${masterPipelineNo} not found`
        );
      }
      filters.masterPipelineNo = masterPipelineNo;
    }

    if (previousOrderNo) {
      const previousOrder = await Order.findOne({
        where: { orderNo: previousOrderNo },
      });
      if (!previousOrder) {
        return sendErrorResponse(
          res,
          404,
          `Previous order with orderNo ${previousOrderNo} not found`
        );
      }
      filters.previousOrderNo = previousOrderNo;
    }

    if (shipTo) {
      const address = await Address.findByPk(shipTo);
      if (!address) {
        return sendErrorResponse(
          res,
          404,
          `Address with ID ${shipTo} not found`
        );
      }
      filters.shipTo = shipTo;
    }

    const searchFilter = search
      ? {
          [Op.or]: [
            { source: { [Op.like]: `%${search}%` } },
            { "$customer.name$": { [Op.like]: `%${search}%` } },
          ],
        }
      : {};

    const include = [
      {
        model: Customer,
        as: "customer",
        attributes: ["customerId", "name"],
        required: search ? false : undefined,
      },
      {
        model: User,
        as: "creator",
        attributes: ["userId", "username", "name"],
      },
      {
        model: User,
        as: "assignedUser",
        attributes: ["userId", "username", "name"],
      },
      {
        model: User,
        as: "secondaryUser",
        attributes: ["userId", "username", "name"],
      },
      {
        model: Team,
        as: "assignedTeam",
        attributes: ["id", "teamName"],
      },
      {
        model: Order,
        as: "previousOrder",
        attributes: ["id", "orderNo"],
      },
      {
        model: Order,
        as: "masterOrder",
        attributes: ["id", "orderNo"],
      },
      {
        model: Address,
        as: "shippingAddress",
        attributes: ["addressId"],
      },
    ];

    const offset = (pageNum - 1) * limitNum;

    const orders = await Order.findAll({
      where: { ...filters, ...searchFilter },
      include,
      order: [["createdAt", "DESC"]],
      limit: limitNum,
      offset,
    });

    const ordersWithComments = await Promise.all(
      orders.map(async (order) => {
        const { comments } = await fetchCommentsWithUsers(
          order.id,
          "Order",
          1,
          10
        );
        return {
          ...order.toJSON(),
          comments,
        };
      })
    );

    const totalCount = await Order.count({
      where: { ...filters, ...searchFilter },
      include: search ? include : [],
    });

    return res.status(200).json({
      orders: ordersWithComments,
      totalCount,
      page: pageNum,
      limit: limitNum,
    });
  } catch (err) {
    return sendErrorResponse(
      res,
      500,
      "Failed to fetch filtered orders",
      err.message
    );
  }
};

// Update order team
exports.updateOrderTeam = async (req, res) => {
  try {
    const { id, assignedTeamId } = req.body;

    if (!id) {
      return sendErrorResponse(res, 400, "Order ID is required");
    }

    const order = await Order.findByPk(id, {
      include: [
        {
          model: Address,
          as: "shippingAddress",
          attributes: ["addressId"],
        },
      ],
    });
    if (!order) {
      return sendErrorResponse(res, 404, "Order not found");
    }

    if (assignedTeamId) {
      const team = await Team.findByPk(assignedTeamId);
      if (!team) {
        return sendErrorResponse(res, 400, "Assigned team not found");
      }
    }

    const previousTeamId = order.assignedTeamId;
    order.assignedTeamId = assignedTeamId || null;
    await order.save();

    // Fetch customer for notification
    const customer = await Customer.findByPk(order.createdFor);
    const addressInfo =
      order.shipTo && order.shipToAddress
        ? `, to be shipped to ${
            order.shipToAddress.address || "address ID " + order.shipTo
          }`
        : "";

    // Send notification to creator, assignedUserId, and secondaryUserId
    const recipients = new Set(
      [order.createdBy, order.assignedUserId, order.secondaryUserId].filter(
        (id) => id
      )
    );
    for (const recipientId of recipients) {
      await sendNotification({
        userId: recipientId,
        title: `Order Team Updated #${order.orderNo}`,
        message: `The team for order #${order.orderNo} for ${
          customer?.name || "Customer"
        }${addressInfo} has been updated.`,
      });
    }

    // Send notification to admin
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Order Team Updated #${order.orderNo}`,
      message: `The team for order #${order.orderNo} for ${
        customer?.name || "Customer"
      }${addressInfo} has been updated.`,
    });

    // Notify new team members if assignedTeamId changed
    if (assignedTeamId && assignedTeamId !== previousTeamId) {
      const teamMembers = await User.findAll({
        include: [
          {
            model: Team,
            as: "teams",
            where: { id: assignedTeamId },
          },
        ],
        attributes: ["userId", "name"],
      });
      for (const member of teamMembers) {
        await sendNotification({
          userId: member.userId,
          title: `Order Assigned to Team #${order.orderNo}`,
          message: `Order #${
            order.orderNo
          } has been assigned to your team for ${
            customer?.name || "Customer"
          }${addressInfo}.`,
        });
      }
    }

    return res.status(200).json({ message: "Order team updated", order });
  } catch (err) {
    return sendErrorResponse(
      res,
      500,
      "Failed to update order team",
      err.message
    );
  }
};

// Upload invoice and link to order
exports.uploadInvoiceAndLinkOrder = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }

    const ext = path.extname(req.file.originalname);
    const uniqueName = `${uuidv4()}${ext}`;

    const client = new ftp.Client();
    client.ftp.verbose = process.env.NODE_ENV === "development";

    let fileUrl;
    try {
      await client.access({
        host: process.env.FTP_HOST,
        port: process.env.FTP_PORT || 21,
        user: process.env.FTP_USER,
        password: process.env.FTP_PASSWORD,
        secure: process.env.FTP_SECURE === "true" || false,
      });

      const cwd = await client.pwd();
      const uploadDir = "/invoice_pdfs";
      await client.ensureDir(uploadDir);
      await client.cd(uploadDir);

      const stream = bufferToStream(req.file.buffer);
      await client.uploadFrom(stream, uniqueName);

      fileUrl = `${process.env.FTP_BASE_URL}/invoice_pdfs/${uniqueName}`;
    } catch (ftpErr) {
      return res
        .status(500)
        .json({ message: "FTP upload failed", error: ftpErr.message });
    } finally {
      client.close();
    }

    const [updated] = await Order.update(
      { invoiceLink: fileUrl },
      { where: { id: req.params.orderId } }
    );

    if (!updated) {
      return res.status(404).json({ message: "Order not found" });
    }

    const order = await Order.findByPk(req.params.orderId);
    const customer = await Customer.findByPk(order.createdFor);

    // Send notification to creator, assignedUserId, and secondaryUserId
    const recipients = new Set(
      [order.createdBy, order.assignedUserId, order.secondaryUserId].filter(
        (id) => id
      )
    );
    for (const recipientId of recipients) {
      await sendNotification({
        userId: recipientId,
        title: `Invoice Uploaded for Order #${order.orderNo}`,
        message: `An invoice has been uploaded for order #${
          order.orderNo
        } for ${customer?.name || "Customer"}.`,
      });
    }

    // Send notification to admin
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Invoice Uploaded for Order #${order.orderNo}`,
      message: `An invoice has been uploaded for order #${order.orderNo} for ${
        customer?.name || "Customer"
      }.`,
    });

    return res.status(200).json({
      message: "Invoice uploaded successfully",
      filename: uniqueName,
      size: req.file.size,
      fileUrl,
    });
  } catch (err) {
    return res
      .status(500)
      .json({ message: "Server error", error: err.message });
  }
};

// Count orders (no notification needed)
exports.countOrders = async (req, res) => {
  try {
    const { date } = req.query;
    if (!date || !moment(date, "YYYY-MM-DD").isValid()) {
      return res
        .status(400)
        .json({ message: "Invalid date format. Use YYYY-MM-DD" });
    }

    const startOfDay = moment(date).startOf("day").toDate();
    const endOfDay = moment(date).endOf("day").toDate();

    const count = await Order.count({
      where: {
        createdAt: {
          [Op.gte]: startOfDay,
          [Op.lte]: endOfDay,
        },
      },
    });

    res.json({ count });
  } catch (error) {
    res.status(500).json({ message: "Server error" });
  }
};
// ──────── ISSUE GATE-PASS ────────
exports.issueGatePass = async (req, res) => {
  try {
    if (!req.file) {
      return sendErrorResponse(res, 400, "No file uploaded");
    }

    const { orderId } = req.params;
    const order = await Order.findByPk(orderId);
    if (!order) return sendErrorResponse(res, 404, "Order not found");

    // reuse the same FTP upload you already have for invoices
    const fileUrl = await uploadToCDN(req.file); // <-- already defined in your file

    await order.update({ gatePassLink: fileUrl });

    // ---------- NOTIFICATIONS ----------
    const customer = await Customer.findByPk(order.createdFor);
    const recipients = new Set(
      [order.createdBy, order.assignedUserId, order.secondaryUserId].filter(
        Boolean
      )
    );
    for (const uid of recipients) {
      await sendNotification({
        userId: uid,
        title: `Gate-Pass Issued #${order.orderNo}`,
        message: `Gate-pass uploaded for order #${order.orderNo} – ${
          customer?.name || ""
        }.`,
      });
    }
    await sendNotification({
      userId: ADMIN_USER_ID,
      title: `Gate-Pass Issued #${order.orderNo}`,
      message: `Gate-pass uploaded for order #${order.orderNo}.`,
    });

    return res.status(200).json({
      message: "Gate-pass uploaded",
      gatePassLink: fileUrl,
    });
  } catch (err) {
    return sendErrorResponse(res, 500, "Gate-pass upload failed", err.message);
  }
};
